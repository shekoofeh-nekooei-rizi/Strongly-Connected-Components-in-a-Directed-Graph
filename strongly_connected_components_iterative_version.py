# -*- coding: utf-8 -*-
"""strongly_connected_components_iterative_version.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OUn7iMZFogC73hC1-h0pEdr_sCPX-GIV
"""



"""**Author: Shekoofeh Nekooei Rizi**

This program computes Strongly Connected Components (SCCs) of a given directed graph.


I implemented Kosaraju's algorithm for this purpose.


In this implementation I used an iterative approach rather than a recursive approach.

In other words, for the depth-first-search, I used stacks instead of recursively calling the DFS function.


In this program, the input file specifies the edges of the directed graph. Every row in the file indicates a directed edge.


Integers (starting from 0 or 1) represent vertices.


The output file displays the number of components and lists the vertices belonging to each SCC in separate lines.


This program works fine and fast even for humongous cases such as the one provided in input_file_gigantic_sample, which represents a graph with more than 2 million vertices and 5 million edges.

This sample can also be found here:

https://snap.stanford.edu/data/wiki-Talk.html





"""

from collections import defaultdict

def strongly_connected_components_iterative(number_of_vertices, list_of_edges):
    # Here number_of_vertices is indeed the largest number among vertices. Thus, if vertices start from 0 (rather than 1) then the total number of vertices in the graph is number_of_vertices + 1
    start_vertex = 1
    graph = defaultdict(list)
    graph_rev = defaultdict(list)
    for e in list_of_edges:
        graph[e[0]].append(e[1])
        graph_rev[e[1]].append(e[0])
        if e[0] == 0 or e[1] == 0:
            start_vertex = 0

    visited = set()
    post_order = [] #this is order of vertices after the first dfs traversal (it is post-order)

    for vertex in range(start_vertex, number_of_vertices+1):
        if vertex not in visited:
            stack = [(vertex, False)]
            while stack:
                current_node, finished = stack.pop()
                if finished:
                    post_order.append(current_node)
                elif current_node not in visited:
                    visited.add(current_node)
                    stack.append((current_node, True))
                    for neighbor in graph[current_node]:
                        if neighbor not in visited:
                            stack.append((neighbor, False))

    post_order.reverse()
    visited = set()
    strongly_connected_components = []

    for vertex in post_order:
        if vertex not in visited:
            stack = [vertex]
            current_component = []
            while stack:
                current_node = stack.pop()
                if current_node not in visited:
                    visited.add(current_node)
                    current_component.append(current_node)
                    for neighbor in graph_rev[current_node]:
                        if neighbor not in visited:
                            stack.append(neighbor)
            strongly_connected_components.append(current_component)

    return strongly_connected_components

def read_input_file(file_name):
    n_of_vertices = 0
    list_of_edges = []
    with open(file_name, 'r') as file:
        for line in file:
            u, v = map(int, line.split())
            list_of_edges.append([u,v])
            n_of_vertices = max(n_of_vertices, u, v)
    return n_of_vertices, list_of_edges

def write_output_file(result, output_file_name):
    with open(output_file_name, 'w') as file:
        file.write(f"There are {len(result)} strongly connected components in this graph.\n\n")
        result = sorted(result, key=len, reverse=True)
        for scc in result:
            file.write(str(scc) + "\n")

n, edges = read_input_file("inpu_file.txt")
s_c_c = strongly_connected_components_iterative(n, edges)
write_output_file(s_c_c, "output_file.txt")
